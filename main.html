<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breathing Cosmic Apex</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; cursor: grab; }
        canvas { position: fixed; top: 0; left: 0; filter: contrast(130%) brightness(110%); }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        let width, height, baseSize;
        let time = 0;
        
        let cameraZ = 1800, targetCameraZ = 1800;
        let rotY = 0, targetRotY = 0;
        let rotX = 0, targetRotX = 0;
        let isDragging = false, lastMouseX, lastMouseY;
        
        let vertices = [];
        const edges = [[0, 1], [0, 2], [0, 3], [1, 2], [2, 3], [3, 1]];
        
        // --- 3번 효과: 입자(Star Dust) 데이터 생성 ---
        const particles = [];
        const particleCount = 400; // 입자 개수

        const glowCanvas = document.createElement('canvas');
        const gCtx = glowCanvas.getContext('2d');
        
        function preRenderGlow() {
            const size = 1000;
            glowCanvas.width = size;
            glowCanvas.height = size;
            const grad = gCtx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.1, 'rgba(255, 255, 255, 0.25)');
            grad.addColorStop(0.4, 'rgba(255, 255, 255, 0.03)');
            grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
            gCtx.fillStyle = grad;
            gCtx.fillRect(0, 0, size, size);
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            baseSize = Math.max(width, height) * 7; 
            
            const s = baseSize * 0.8;
            vertices = [
                {x: 0, y: -s, z: 0},
                {x: s * Math.sqrt(8/9), y: s/3, z: 0},
                {x: -s * Math.sqrt(2/9), y: s/3, z: s * Math.sqrt(2/3)},
                {x: -s * Math.sqrt(2/9), y: s/3, z: -s * Math.sqrt(2/3)}
            ];

            // 입자를 삼각뿔 주변 공간에 무작위로 배치
            particles.length = 0;
            for(let i=0; i<particleCount; i++) {
                particles.push({
                    x: (Math.random() - 0.5) * baseSize * 2.5,
                    y: (Math.random() - 0.5) * baseSize * 2.5,
                    z: (Math.random() - 0.5) * baseSize * 2.5,
                    size: Math.random() * 2 + 1
                });
            }

            preRenderGlow();
        }

        window.addEventListener('wheel', e => { 
            targetCameraZ = Math.max(-500, Math.min(targetCameraZ + e.deltaY * 1.5, 15000)); 
        }, { passive: true });
        
        window.addEventListener('mousedown', e => { isDragging = true; lastMouseX = e.clientX; lastMouseY = e.clientY; });
        window.addEventListener('mousemove', e => {
            if (!isDragging) return;
            targetRotY += (e.clientX - lastMouseX) * 0.005;
            targetRotX += (e.clientY - lastMouseY) * 0.005;
            targetRotX = Math.max(-0.8, Math.min(0.8, targetRotX));
            lastMouseX = e.clientX; lastMouseY = e.clientY;
        });
        window.addEventListener('mouseup', () => isDragging = false);
        window.addEventListener('resize', resize);
        resize();

        function rotate3D(v, angleX, angleY) {
            let cosY = Math.cos(angleY), sinY = Math.sin(angleY);
            let x1 = v.x * cosY - v.z * sinY, z1 = v.x * sinY + v.z * cosY;
            let cosX = Math.cos(angleX), sinX = Math.sin(angleX);
            return { x: x1, y: v.y * cosX - z1 * sinX, z: v.y * sinX + z1 * cosX };
        }

        function project(v) {
            cameraZ += (targetCameraZ - cameraZ) * 0.05;
            rotY += (targetRotY - rotY) * 0.05;
            rotX += (targetRotX - rotX) * 0.05;
            const perspective = 1200;
            const scale = perspective / (perspective + v.z + cameraZ);
            return { x: v.x * scale + width * 0.5, y: v.y * scale + height * 0.5, scale: scale };
        }

        function drawGrandLight(p1, p2, scale, breath) {
            if (scale <= 0) return;
            const dist = Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
            const steps = Math.min(dist / 0.5, 300); 
            
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (let i = 0; i <= steps; i++) {
                const ratio = i / steps;
                const x = p1.x + (p2.x - p1.x) * ratio;
                const y = p1.y + (p2.y - p1.y) * ratio;
                // --- 1번 효과: 숨쉬는 크기 계산 ---
                const s = 1400 * scale * breath; 
                ctx.drawImage(glowCanvas, x - s/2, y - s/2, s, s);
            }
            ctx.restore();
        }

        function draw() {
            time += 0.003; 
            
            // --- 1번 효과: 호흡 주기 (0.8 ~ 1.2 사이를 왕복) ---
            const breath = 1 + Math.sin(time * 2) * 0.2;
            
            const autoRotY = time * 0.15;
            const autoRotX = Math.sin(time * 0.4) * 0.15;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            const currentRotX = rotX + autoRotX;
            const currentRotY = rotY + autoRotY;

            // 3번 효과: 배경 입자 먼저 그리기
            ctx.fillStyle = "white";
            particles.forEach(p => {
                const rotated = rotate3D(p, currentRotX, currentRotY);
                const proj = project(rotated);
                if (proj.scale > 0) {
                    const alpha = Math.min(1, proj.scale * 2);
                    ctx.globalAlpha = alpha;
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, p.size * proj.scale, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.globalAlpha = 1;

            // 삼각뿔 그리기
            const proj = vertices.map(v => project(rotate3D(v, currentRotX, currentRotY)));
            
            edges.forEach(edge => {
                const p1 = proj[edge[0]], p2 = proj[edge[1]];
                drawGrandLight(p1, p2, (p1.scale + p2.scale) / 2, breath);
            });

            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            edges.forEach(edge => {
                const p1 = proj[edge[0]], p2 = proj[edge[1]];
                ctx.beginPath();
                // 선의 불투명도도 호흡에 맞춰 변화
                ctx.strokeStyle = `rgba(255, 255, 255, ${Math.min(0.6, p1.scale) * breath})`;
                ctx.lineWidth = 1.3 * breath;
                ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            });
            ctx.restore();

            requestAnimationFrame(draw);
        }
        draw();
    </script>
</body>
</html>
